/*
  * Author: VadRov
  * Copyright (C) 2019, VadRov, all rights reserved.
  *
  * Incremental mechanical encoder driver.
  *
  * Free distribution allowed.
  * For any method of distribution, attribution to the author is MANDATORY.
  * In case of changes and distribution of modifications, the indication of the original author is MANDATORY.
  * Distributed “as is”, that is, use is at your own peril and risk.
  * The author does not provide any guarantees.
  *
  *Version: for STM32F4
  *
  *	Requirements:
  * - three MK outputs, configured as inputs with external EXTI interrupts on falling and rising edges;
  * - system timer SysTick, configured to interrupt at a frequency of 1000 times per second (used for
  * "system time" when setting a time threshold for debouncing and determining time
  * pressing a button);
  * - incremental mechanical encoder with a button, i.e. with three outputs: A, B, C (button);
  * - ideally a pair of ceramic capacitors 0.02-0.1 µF (one in parallel between the outputs
  * encoder A and "ground", B and "ground");
  * - pull-up of MK inputs to power supply (internal - Pull up option or external - through resistors).
  *
  * Features and capabilities:
  * - Exclusively EXTI interrupts are used, which completely eliminates the need for constant cyclic
  * polling the encoder state, as would be the case if excessively frequent update interrupts were used
  * timer. Those. analysis of encoder states is carried out only when required - by interrupts,
  * generated by signals from its outputs.
  * - Noise immunity and clarity of encoder operation due to the algorithm for processing the states of the encoder outputs and
  * use of interruptions "in two directions" (on the falling - falling and rising - rising edges at the MK inputs).
  * - Due to the use of “two-way” interrupts simultaneously on two encoder outputs A and B, there is no need for
  * organizing artificial delays in the interrupt handler, as can be found in various sources
  * in a network where only a falling edge interrupt is used on one of the two encoder outputs. Also for
  * by using this approach, the requirements for encoder quality are reduced. The driver, in general, is equally good
  * works out both slow and fast rotations of the encoder knob.
  * - There are no artificial delays in the driver program.
  * - Low computational load on the MK core.
  * - The driver generates 6 significant events: rotating the encoder knob forward/backward, briefly pressing the button and
  * holding the button, rotating the encoder knob forward/backward while the button is pressed.
  * - The driver allows you to swap the generation of forward/reverse rotation events and forward/reverse rotation events when
  * pressed button, i.e. allows software inversion of the direction of operation of the encoder without the need
  * hardware reconnection of outputs.
 *
 *  https://www.youtube.com/@VadRov
 *  https://dzen.ru/vadrov
 *  https://vk.com/vadrov
 *  https://t.me/vadrov_channel
 */

#include "encoder.h"
#include <string.h>

extern uint32_t millis; /* Global variable incremented every millisecond
						   in the system timer interrupt SysTick.						 */

enum {						/* Encoder output status: */
	   ENCODER_NONE = 0,	/* - there is not a single active output; */
	   ENCODER_A    = 1,	/* - output active A; */
	   ENCODER_B    = 2,	/* - output active B; */
	   ENCODER_AB   = 3,	/* - outputs A and B active; */
	   ENCODER_C    = 4,	/* - output C is active (button);*/
	   ENCODER_ABС  = 7		/* - outputs active A, B, С. */
};

/* Table for determining increments to the encoder counter depending on the state of its outputs A, B. */
static const int8_t ENCODER_inc_tbl[] = {0, -1, 1, 0, 1, 0, 0, -1, -1, 0, 0, 1, 0, 1, -1, 0};

/* Initializes encoder enc. */
void EncoderInit(ENCODER_Handler *enc,
				 GPIO_TypeDef *a_port, uint16_t a_pin,
				 GPIO_TypeDef *b_port, uint16_t b_pin,
				 GPIO_TypeDef *c_port, uint16_t c_pin)
{
	memset(enc, 0, sizeof(ENCODER_Handler)); /* Initializing encoder handler memory */
	/* Pin assignment of ports connected to encoder outputs */
	enc->a_port = a_port; /* Encoder output A */
	enc->a_pin = a_pin;
	enc->b_port = b_port; /* Encoder output B */
	enc->b_pin = b_pin;
	enc->c_port = c_port; /* Encoder output C (button) */
	enc->c_pin = c_pin;
}

/*
  * Queries the status of the encoder outputs and updates its handler.
  * Returns one of the events that was generated at the time the update request was received:
  * ENCODER_EV_NONE - no events;
  * ENCODER_EV_FWD - rotate the encoder knob clockwise;
  * ENCODER_EV_BCK - rotate the encoder knob counterclockwise;
  * ENCODER_EV_BTN_CLICK - short press on the button;
  * ENCODER_EV_BTN_HOLD - button hold;
  * ENCODER_EV_FWD_BTN - rotate the encoder knob clockwise while the button is pressed;
  * ENCODER_EV_BCK_BTN - rotate the encoder knob counterclockwise while the button is pressed.
  * enc - pointer to the encoder handler.
  * ch_irq - output of the encoder through which the update request was received.
  * ch_irq accepts the values ENCODER_IRQ_NONE, ENCODER_IRQ_A, ENCODER_IRQ_B, ENCODER_IRQ_C.
  * The EncoderUpdate function must be called from the appropriate external EXTI interrupt handlers.
  */
uint8_t EncoderUpdate(ENCODER_Handler *enc, uint8_t ch_irq)
{
	uint8_t event = ENCODER_EV_NONE; /* Initialize the current event: no events. */
	uint8_t keys = ENCODER_NONE;     /* Initializing the state variable of the encoder outputs: no active outputs. */

	/* We poll the outputs of the encoder (they are also the inputs of the MK) and form the value in the keys variable,
	corresponding to the current state of the encoder outputs. */
	if (!(enc->a_port->IDR & enc->a_pin)) keys = ENCODER_A;  /* Output A is active (pressed to ground): set the ENCODER_A bit. */
	if (!(enc->b_port->IDR & enc->b_pin)) keys |= ENCODER_B; /* Active output B (attached to "ground"): set to ENCODER_B. */
	if (!(enc->c_port->IDR & enc->c_pin)) keys |= ENCODER_C; /* Active output C (attached to "ground"): set to ENCODER_C. */

	if ((enc->prev_event == ENCODER_EV_FWD_BTN ||	/* Block the possibility of a “related” event in the form of ENCODER_EV_BTN or */
	    enc->prev_event == ENCODER_EV_BCK_BTN) &&	/* ENCODER_EV_BTN_HOLD when generating ENCODER_EV_FWD_BTN and       */
		ch_irq == ENCODER_IRQ_C) {					/* ENCODER_EV_BCK_BTN, which will occur when the button is released.     */
		enc->fl_click_btn = 0;						/* Let's reset the button click flag. */
		enc->time_bounce_btn = millis + 3000;		/* Let's set a time threshold of 3 seconds to block “incidental” events.*/
		enc->prev_event = event;
		return event;
	}

	/* Detecting encoder rotation events. Events ENCODER_EV_FWD and ENCODER_EV_BCK. */
	if (ch_irq == ENCODER_IRQ_A || ch_irq == ENCODER_IRQ_B) { /* If an update request is received from outputs A or B. */
		int8_t inv = !enc->inversion ? 1: -1; //Encoder operating mode sign: direct(+)/inverse(-)
		enc->inc_idx <<= 2; /* Previous state of the encoder outputs, expressed as an index value inc_idx,
    						   defines the base index value in the increment table for analyzing the current
    						   encoder status and event detection. We move along the table from the current one
    						   index inc_idx to index inc_idx * 4. */
		enc->inc_idx |= keys & ENCODER_AB;  /* Depending on the current state of the encoder outputs, we add
    										   offset to the resulting index. This offset takes the value
    										   0 to 3 (the two bits defining the outputs give 4 possible combinations). */
		/* Increment the encoder counter with a value depending on the increment value obtained from
		table, and encoder operating mode (direct or inverse). At the same time, we limit the value of the index inc_idx
		4 low-order digits (index value inc_idx in the range from 0 to 15).                                 */
		enc->encCounter += inv * ENCODER_inc_tbl[enc->inc_idx & (sizeof(ENCODER_inc_tbl) - 1)];
		/* Check whether the conditions for generating events are met. */
		if (enc->encCounter >= ENCODER_THRESHOLD) { /* Has the counter reached the threshold for the ENCODER_EV_FWD event? */
			event = ENCODER_EV_FWD;	/* Event ENCODER_EV_FWD. */
			if (keys & ENCODER_C) {
				event = ENCODER_EV_FWD_BTN; /* If the button is pressed, then the event ENCODER_EV_FWD_BTN. */
				enc->fl_click_btn = 0;		/* Reset the pressed button flag */
			}
			enc->inc_idx = enc->encCounter = 0; 	/* Initializing the encoder counter. */
		}
		else if (enc->encCounter <= -ENCODER_THRESHOLD) { /* The counter has reached the event threshold ENCODER_EV_BCK? */
			event = ENCODER_EV_BCK; /* Event ENCODER_EV_BCK. */
			if (keys & ENCODER_C) {
				event = ENCODER_EV_BCK_BTN; /* If the button is pressed, then the event ENCODER_EV_BCK_BTN. */
				enc->fl_click_btn = 0;		/* Reset the pressed button flag */
			}
			enc->inc_idx = enc->encCounter = 0;	/* Initializing the encoder counter. */
		}
	}
	/* Defining events of short pressing and holding the encoder button.
	   Events ENCODER_EV_BTN_CLICK и ENCODER_EV_BTN_HOLD.                       */
	else if (ch_irq == ENCODER_IRQ_C) { /* If a request for update is received from output C (button). */
		if (enc->time_bounce_btn <= millis) { /* Whether the current system time has reached the specified value (threshold)
											     to eliminate chatter when pressing and releasing a button? */
			keys &= ENCODER_C;				  /* We obtain the state of output C by selecting it from the set of outputs. */
			if (enc->fl_click_btn && !keys) { /* Did we hit the handler because we released the button? */
				enc->fl_click_btn = 0;									/* Reset the button click flag. */
				enc->time_bounce_btn = millis + ENCODER_BTN_BOUNCE;		/* Set a time threshold to eliminate chatter when the button is released. */
				event = ENCODER_EV_BTN_CLICK;							/* Define an event: a short press on a button. */
				if (millis - enc->time_click_btn >= ENCODER_BTN_HOLD) { /* Has the button press time reached the hold time? */
					event = ENCODER_EV_BTN_HOLD;						/* If yes, then define an event: holding the button. */
				}
			}
			else if (!enc->fl_click_btn && keys) {	/* We got into the handler because we clicked a button? */
				enc->fl_click_btn = 1;				/* Set the button click flag. */
				enc->time_click_btn = millis;		/* Remember the current system time to calculate the duration of holding the button. */
				enc->time_bounce_btn = millis + ENCODER_BTN_BOUNCE; /* Set the time threshold for eliminating bounce when the button is pressed. */
			}
		}
	}
	enc->prev_event = event;
	return event; /* Return the current event. */
}

/*
  * The function determines the operating mode of the encoder: direct (inv = ENCODER_INV_OFF) and reverse/inverse (inv = ENCODER_INV_ON).
  * In inverse operating mode, encoder events are swapped: ENCODER_EV_FWD with ENCODER_EV_BCK,
  * ENCODER_EV_FWD_BTN with ENCODER_EV_BCK_BTN.
  */
void inline EncoderSetInversion(ENCODER_Handler *enc, uint8_t inv)
{
	enc->inversion = inv;
}
